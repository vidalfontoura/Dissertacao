\chapter{Referencial Teórico}
\label{cap:Referencial Teórico}

% figuras estão no subdiretório "figuras/" dentro deste capítulo
\graphicspath{\currfiledir/figuras/}

%=====================================================

\section{PDP - Problema de Dobramento de Proteínas}

Proteínas são estruturas básicas, essenciais para vida e possuem incontáveis funções biológicas. Proteínas são sintetizadas pelos ribossomos seguindo um formato provido pelo mensageiro RNA (mRNA). Durante a síntese, as proteínas dobram (enovelam) em uma estrutura tridimensional única, conhecida como conformação nativa. Este processo é chamado: dobramento de proteínas (\textit{protein folding}). A função biológica de uma proteína depende da sua estrutura tridimensional.

As proteínas são polímeros compostos por sequências de aminoácidos (também chamados de resíduos) conectados linearmente por ligações peptídicas. Cada aminoácido é composto por um átomo central de carbono ($C\alpha$) conectado a um átomo de hidrogênio, um grupo amina, um grupo carboxila e uma cadeia lateral (\textit{side-chain}) a qual confere a cada aminoácido uma função distinta. Uma ligação peptídica é formada por dois aminoácidos quando o grupo carboxila de uma molécula reage com o grupo amina da outra. Este processo de agregação de aminoácidos é conhecido como desidratação pois libera uma molécula de água ($H_2O$) \cite{suzuki1986introduction}. Proteínas podem ser chamadas de cadeias polipeptídicas. Todos os aminoácidos tem o mesmo \textit{backbone} e se diferem dos outros apenas pela \textit{side-chain}, a qual pode ser um simples átomo de hidrogênio ou até um grupo heterocíclico complexo. A \textit{side-chain} define as propriedades físicas e químicas dos aminoácidos de uma proteína \cite{cox2013lehninger}.

%\subsection{Estrutura hierárquica e função das proteínas}

%As proteínas são tradicionalmente descritas em quatro níveis hierárquicos de %complexidade \cite{cox2013lehninger}:

%\begin{enumerate}
%	\item Estrutura primária: Nível de organização simples que visa representar apenas a sequência de aminoácidos de maneira linear. Representa apenas as ligações peptídicas entre os aminoácidos. (Colocar imagem?)
%	\item Estrutura secundária: Consiste em arranjos espaciais de regiões locais de uma proteína. Existem três estruturas secundárias importantes $\alpha$-hélices(PAULING; COREY; BRANSON, 1951a), $\beta$-folhas
%	(PAULING; COREY; BRANSON, 1951b) e turns (dobras) (LEWIS; MOMANY;
%	SCHERAGA, 1973).
%	$\alpha$-hélices é a forma mais comum de estrutura secundária. É uma estrutura semelhante a um bastão, onde o \textit{backbone} firmemente 
%	helicoide forma a parte interna do bastão, e as \textit{side-chains} se projetam para fora em uma disposição helicoidal(http://labs.icb.ufmg.br/lbcd/grupo1/alfa.html). $\beta$-folhas formada por 2 ou mais segmentos polipeptídicos da mesma molécula, ou de moléculas diferentes, dispostos lateralmente e estabilizados por pontes de hidrogênio entre os grupos $NH$ e $CO$.  (Benítez)
%	\textit{Turns} são compostos de três ou quatro aminoácidos e geralmente são localizados na superfície das proteínas formando dobras que redirecionam a cadeia polipeptídica para o interior da proteína. \textit{Turns} permitem que as proteínas sejam dobradas em estruturas altamente compactas.	As estruturas secundárias podem ser associadas formando estruturas super secundárias, chamadas de \textit{motifs} (BRANDEN; TOOZE, 1999; GRIFFITHS
%	et al., 2000; NÖLTING, 2006). Os \textit{motifs}  são padrões frequentemente encontrados em estruturas tridimensionais.
%\item Estrutura terciária: Trata do arranjo tridimensional dos aminoácidos que compõem uma proteína. Enquanto as estruturas secundárias são estabilizadas por pontes de hidrogênio, as estruturas terciárias são estabilizadas por iterações entre \textit{side-chains} hidrofóbicas e pontes de hidrogênio entre \textit{side-chains} polares. A estrutura terciária representa o dobramento de um polipeptídeo como resultado das interações entre as \textit{side-chains} dos aminoácidos que se encontram em diferentes regiões da estrutura primária.
%	\item Estrutura quaternária: É o nível de representação mais complexo e descreve o arranjo de duas mais subunidades polipeptídicas dobradas (estruturas terciárias) no espaço.
%A associação quaternária pode ser entre diferentes tipos de polipeptídeos (heterodímero)
%ou entre polipeptídeos idênticos (homodímero). Este nível de organização	descreve o número e posições relativas de subunidades em proteínas
%multiméricas. A Hemoglobina é um exemplo de proteína multimérica, pois é composta de duas cópias de polipeptídeos diferentes que interagem entre si. 

%\end{enumerate}

\section{Dobramento de proteínas}

É o processo em que cada cadeia polipeptídica é transformada em uma estrutura compacta que realiza alguma função biológica \cite{grantcharova2001mechanisms}. Estas funções incluem controle e regulação de processos químicos essenciais para os organismos vivos \cite{branden1999introduction}. A estrutura tridimensional mais estável é chamada de conformação nativa e é a qual permite que a proteína exerça corretamente sua função biológica \cite{lodish2000molecular, pedersen2000algorithms}.

Experimentos conduzidos por Anfinsen et al. \cite{sela1957reductive, anfinsen1972studies, anfinsen1961kinetics}, mostraram que as proteínas possuem apenas uma conformação nativa e que as informações essenciais que codificam a estrutura estão contidas na sequência de aminoácidos. A conformação tridimensional nativa é dada pela estrutura primária (sequência de aminoácidos) de uma proteína.

Muitas proteínas podem desnaturar por modificações no ambiente em que estão inseridas, conforme demonstrado por \cite{sela1957reductive, anfinsen1972studies, anfinsen1961kinetics}. Durante o processo de desnaturação as proteínas perdem sua forma nativa (desdobram) e, consequentemente, perdem sua função. O exemplo mais conhecido de desnaturação proteica é o da clara do ovo. A clara do ovo é composta por água e albumina. A albumina é uma proteína polar, portanto solúvel em 
água. Ao fritar ou cozinhar o ovo, eleva-se a temperatura, levando à desnaturação da albumina que, mesmo ao retornar à temperatura original, não consegue voltar à sua conformação nativa. Além de se desdobrarem é possível que ocorram erros de dobramento na formação das proteínas causando com que a proteína não exerça sua função biológica corretamente. Estudos tentam identificar causas para os erros de dobramento das proteínas pois muitas enfermidades são causadas pelo mal dobramento de proteínas como, por exemplo, mal de Alzheimer \cite{hutton2001analysis, selkoe2001clearing}, alguns tipos de câncer \cite{bell2002p53, dawson2003n, ishimaru2003fibrillar}, fibrose cística \cite{thomas1992altered}, arteriosclerose
\cite{ursini2002atherosclerosis}, mal de Parkinson \cite{mcnaught2001failure}, entre outras. 
Portanto, entender como o processo de dobramento de proteínas ocorre é de fundamental importância. Um dos objetivos comuns das ciências biológicas é caracterizar funcionalmente sequências de proteínas através da resolução de suas conformações nativas \cite{eswar2003tools}. Varias áreas da ciência, tais como Biologia, Medicina, Química Orgânica, realizam diferentes estudos das proteínas. Muitos destes estudos são voltados para o processo de dobramento das proteínas que pode sofrer alterações: tanto em como a conformação estará disposta no espaço, como ela estará agrupada e sobre sua má formação. Isto é muito relevante para estudos que visam à produção de medicamentos, suplementos alimentares, técnicas que manipulam o DNA, ou para formação de novos compostos proteicos sintéticos em laboratório \cite{devlin1998manual}. É importante mencionar que apesar do avanço na grande quantidade de proteínas que se tem conhecimento por conta de projetos de sequenciamento genômico, apenas uma pequena fração de estruturas tridimensionais é conhecida.

A cristalografia de raios-X e espectroscopia de RNM são os métodos experimentais mais poderosos para o estudo da estruturas de proteínas \cite{ilari2008protein} \cite{gobl2012application}. Entretanto estes métodos são altamente custosos tanto em esforços computacionais, de tempo e financeiros, e estão disponíveis apenas para algumas instituições.


Embora o conceito de dobramento de proteínas tenha surgido da área de biologia molecular, este problema é um problema interdisciplinar, o qual requer apoio de muitas áreas do conhecimento, e é considerado como um dos desafios atuais mais importantes da biologia e bioinformática \cite{nicosia2008generalized}. 

Na biologia computacional existem dois problemas que tratam sobre o dobramento de proteínas. São eles: problema de predição estrutura de proteínas (ou PSP - \textit{Protein Structure Prediction}), que trata de predizer a estrutura tridimensional (conformação) a partir de sua sequência (estrutura primária); e o problema de dobramento de proteínas (PDP ou PFP - \textit{Protein Folding Problem}), o qual trata da determinação dos passos/eventos que conduzem o dobramento a partir da estrutura primária até a conformação nativa \cite{lopes2008evolutionary}. Porém, na literatura, é encontrado ambos os termos sendo utilizados sem nenhuma distinção, normalmente se referindo apenas ao primeiro problema \cite{lopes2008evolutionary}.  

A ciência da computação desempenha um papel importante nisto, propondo e desenvolvendo modelos e soluções computacionais para o estudo de ambos os problemas PSP e PDP \cite{lopes2008evolutionary}. Muitas estratégias computacionais descrevem modelos de predição de estruturas de proteínas com diferentes níveis de detalhamento e complexidade mas que permitem uma representação fidedigna da estrutura tridimensional, sem perda de viabilidade computacional \cite{benitez2015algoritmo}. Dessa maneira  evita-se a obrigatoriedade do uso de métodos caros, aumentando a competitividade e auxiliando na consolidação de centros de pesquisa que desenvolvem estudos nesta área \cite{dill2000polymer}.

Acredita-se que a conformação nativa de uma proteína é a sua estrutura mais estável, adquirindo um estado de energia livre mínima, o que gerou a chamada hipótese da termodinâmica \cite{pedersen2000algorithms}. Os modelos de predição de estruturas normalmente são baseados nas leis da termodinâmica onde o problema é modelado como um problema de minimização da energia livre a respeito das possíveis conformações que uma proteína pode assumir \cite{benitez2015algoritmo}. A minimização da energia livre é assumida como o principal fator para a formação da estrutura da proteína. Portanto, a conformação nativa de uma proteína é dada por aquela que possuir o menor valor de energia livre.

Segundo \cite{pedersen2000algorithms}, um modelo computacional deve possuir algumas características:

\begin{itemize}
	\item Um conjunto de entidades que representam os átomos e as ligações entre eles. 
	\item Regras que definem as possíveis conformações.
	\item Uma função que seja computacionalmente factível, para calcular a energia livre das possíveis conformações.
\end{itemize}

A próxima subseção irá discorrer sobre alguns modelos de representação de estruturas de proteínas.

\section{Modelos de Representação de Proteínas}

Em suma existem duas classes de modelos de representação de estruturas de proteínas: analítico (também conhecido como \textit{all atom}) e discreto (chamado também de \textit{coarse-grained}). Os modelos analíticos possuem uma descrição detalhada da estrutura tridimensional incluindo informações de todos os átomos que constituem uma proteína. Já os modelos discretos descrevem as proteínas com um nível bastante reduzido de detalhes. Os modelos discretos recentemente ganharam maior interesse, por conta de dois fatores: a simulação de modelos analíticos nem sempre é computacionalmente possível e modelos discretos possibilitam simulações biologicamente relevantes com melhor aproveitamento  computacional \cite{benitez2015algoritmo}. Embora simulações utilizando modelos discretos ainda não possam ser consideradas tão preditivas quanto simulações analíticas, avanços notáveis têm: sido alcançados, referente ao uso de metodologias mais rigorosas e criação de algoritmos para melhor explorar o espaço de busca \cite{tozzini2005coarse}. Esta proposta irá descrever apenas os modelos discretos pois visa a utilização do modelo hidrofóbico polar (HP) 2D.

\subsection{Modelos Discretos}

Os modelos computacionais mais simples são os conhecidos como modelos de grade (\textit{lattice models}). Estes modelos consideram as estruturas de proteínas como um colar de esferas posicionado em uma grade. O grau de liberdade dos movimentos é restrito à estrutura da grade, que pode ser 2D (plano) ou 3D (espacial). Conformações válidas são aquelas que os aminoácidos adjacentes na sequência também são adjacentes na grade e cada aminoácido ocupe uma posição distinta na grade. Muitos modelos de grade têm sido propostos e aplicados ao PDP. Os modelos 2D-HP e 3D-HP são exemplos de modelos de grade.

\subsubsection{Modelo Hidrofóbico-Polar HP}
\label{subsubsection:modeloHP}

No modelo HP os aminoácidos são classificados em 2 tipos: Hidrofílicos (Polar) e Hidrofóbico. Consequentemente, uma proteína é representada por uma \textit{string} de caracteres definida por um alfabeto binário $\{H,P\}$. Este modelo considera que as interações entre aminoácidos hidrofóbicos (H) representam a contribuição mais importante para a energia livre de uma proteína. Portanto existe uma relação inversamente proporcional: quanto maior for a quantidade de interações hidrofóbicas (H-H), menor será a energia livre de uma proteína. Uma interação hidrofóbica (também conhecida como contato hidrofóbico) é definida como um par de aminoácidos do tipo H-H que não sejam consecutivos na sequência mas sejam adjacentes na grade.
Como dito anteriormente, uma conformação é dita válida quando nenhuma posição da grade é ocupada por mais que um aminoácido. Conformações inválidas possuem colisões entre os aminoácidos. Dada uma conformação válida para o modelo HP e $n$ o número de interações hidrofóbicas, a energia da conformação pode ser facilmente calculada utilizando a equação \ref{equation:energyHp}: 


\begin{align}
	\label{equation:energyHp}
	E(c) = n. (-1) 
	\
\end{align}


Quando uma proteína é dobrada na sua conformação nativa, os aminoácidos hidrofóbicos tendem a se agrupar no interior da estrutura, protegidos por aminoácidos polares posicionados no exterior. Dessa maneira, um núcleo hidrofóbico é formado em proteínas dobradas \cite{benitez2015algoritmo}. 
Embora simples, a estratégia computacional de buscar uma solução para o PDP utilizando modelo HP é considerada como um problema $NP$-completo \cite{atkins1999intractability, berger1998protein, crescenzi1998complexity}. O espaço de busca do modelo HP possui algumas características mencionadas na literatura \cite{bastolla1997testing, berger1998protein, crescenzi1998complexity, krasnogor1999protein, vendruscolo2000can} :

\begin{itemize}
	\item Elevada degenerescência.
	\item Espaço de busca multimodal.
	\item Muitas regiões com conformações inválidas.
\end{itemize}

A figura \ref{fig:exemploModeloHP} apresenta um exemplo para os modelos HP (2D e 3D). Os pontos pretos são aminoácidos do tipo H e os brancos são aminoácidos do tipo P. As linhas pontilhadas representam as interações hidrofóbicas.

%\begin{figure}[!htb]
%	\centering
%	\includegraphics[scale=.9]{modeloHP/modeloHPExemplo.png}
%	\caption{Exemplos de representação de proteínas utilizando os modelos HP 2D-HP (a) e 3D-HP (b). \\ Fonte: Adaptado de \cite{benitez2015algoritmo}}
%	\label{fig:exemploModeloHP}
%\end{figure}


Diversos trabalhos aplicam algoritmos evolucionários e bio-inspirados ao problema de dobramento de proteínas utilizando o modelo HP. Uma decisão comum a todos trabalhos que utilizam o modelo HP é a de como representar as variáveis de entrada. Na literatura é possível encontrar basicamente três representações \cite{krasnogor1999protein, lopes2008evolutionary}: 

\begin{itemize}
	\item Coordenadas cartesianas: Este método  representa a posição de cada aminoácido utilizando suas coordenadas espaciais (x,y) no plano cartesiano 2D ou (x,y,z) no plano cartesiano 3D. Geralmente, sua utilização não é adequada para algoritmos baseados em população, pois estruturas idênticas ou semelhantes podem ter coordenadas totalmente diferentes  \cite{benitez2015algoritmo}; 
	\item Coordenadas internas: Nesta representação as conformações são representadas por conjuntos de movimentos que ditam como a estrutura final irá se parecer. Esta representação é a mais utilizada em abordagens com algoritmos evolucionários para o PDP \cite{benitez2015algoritmo}. Existem duas possibilidades de se representar conformações utilizando coordenadas internas:
	\begin{itemize}
		\item Coordenadas absolutas: Este tipo de coordenada é baseado na orientação do eixo da grade onde a conformação esta contida. No caso de uma grade bidimensional os possíveis movimentos são: $\{N,S,L,O\}$ ou norte,sul,leste e oeste. Já em uma grade 3D os possíveis movimentos são: $\{N,S,L,O,F,T\}$ que correspondem aos mesmos movimentos no caso 2D porém com dois movimentos a mais: para frente e para trás.
		\item Coordenadas relativas: Este tipo de representação define a posição de cada aminoácido da cadeia em relação ao movimento do seu predecessor. O conjunto de movimentos possíveis para a grade 2D é definido por $\{F,E,D\}$, que correspondem aos movimentos: frente (continuar no mesmo sentindo do aminoácido anterior), à esquerda e à direita. Em um cubo 3D, os possíveis movimentos são $\{F,E,D,C,B,\}$, possuindo dois movimentos a mais: para cima e para baixo. 
	\end{itemize}
	\item Matriz de distâncias: descreve a conformação de uma proteína através de uma matriz quadrada que representa a distância entre os aminoácidos. Este tipo de representação é raramente utilizado na literatura \cite{benitez2015algoritmo}.
\end{itemize}



\subsubsection{Outros Modelos}


Além do modelo HP, outros modelos simples em grade são utilizados para representar a estrutura de proteínas em outros estudos encontrados na literatura. Por exemplo:

\begin{itemize}
	\item Modelo PH (\textit{Perturbed Homopolymer}): Proposto por Shakhnovich et al. \cite{shakhnovich1993engineering}, as reações entre aminoácidos hidrofóbicos não são levadas em consideração, mas as interações entre aminoácidos do mesmo tipo são favorecidas, ou seja, H-H e P-P, desfavorecendo ligações H-P \cite{benitez2015algoritmo}.
	\item Modelo LPE (\textit{Lattice Polymer Embedding}): Modelo proposto por Unger e Moult \cite{unger1993finding}. A modelagem é feita a partir de uma sequência de aminoácidos, A = $a_1,...a_n$ atrelada a uma grade cúbica. Cada aminoácido possui um coeficiente de afinidade, definido para cada par $a_i,a_j (c(a_i,a_j))$. O objetivo da função de energia é minimizar o produto dos coeficientes pela distância entre os aminoácidos \cite{benitez2015algoritmo}.
	\item Modelo HP-TSSC (\textit{Hydrophobic-Polar Tangent Spheres Side Chain Model}): este modelo
	proposto por Hart et al. \cite{hart1997lattice} é baseado no modelo HP, porém não
	utiliza uma grade. Neste modelo a proteína é modelada via um grafo tridimensional, onde a cadeia lateral e o \textit{backbone}
	de cada aminoácido são esferas de mesmo raio \cite{benitez2015algoritmo}.
	\item Modelo CGE (\textit{Charged Graph Embedding}): Modelo descrito por Ngo et al. \cite{ngo1994protein}. Neste modelo, uma carga (\textit{charge}) é atribuída a cada
	resíduo. Entretanto, as conformações permitidas não são realistas \cite{benitez2015algoritmo}. 
	\item Modelo HPNX: modelo proposto por Bornberg-Bauer \cite{bornberg1997chain}. Divide
	os 20 aminoácidos em 3 classes: hidrofóbicos (H), positivos (P), negativos
	(N) e neutros (X). Este modelo, assim como o modelo HP, utiliza uma grade. Interações entre aminoácidos hidrofóbicos (H-H) representam
	interações de atração e diminuem a energia da conformação em 4,0,
	as interações entre positivos (P-P) e negativos (N-N) representam interações de repulsão e aumentam a energia livre em 1,0 e as interações entre N e P decrescem a energia em 1,0. O objetivo também consiste em minimizar a energia livre. Da mesma maneira que o modelo HP, quanto mais interações hidrofóbicas melhor será o dobramento. Porém este modelo não desconsidera o valor das demais interações \cite{benitez2015algoritmo}.
	\item Modelo HP-helicoidal (Helical-HP): este modelo proposto por Thomas e Dill \cite{thomas1993local} considera apenas uma grade bidimensional e inclui dois tipos de interação: interações não-locais através de energia de contatos hidrofóbicos e interações locais representadas por uma tendência à formação de a-hélices (chamada de propensão hélica) \cite{benitez2015algoritmo}.
	\item Modelo \textit{off-lattice} AB: este modelo proposto por Stillinger et al. \cite{stillinger1993toy} divide os aminoácidos em duas classes de acordo com sua polaridade: Hidrofóbicos (A) e Hidrofílicos (ou polares  B). Inicialmente, este modelo foi aplicado em duas dimensões (2D AB \textit{off-lattice}) e posteriormente aplicado para três dimensões (3D AB \textit{off-lattice}). Os aminoácidos não consecutivos interagem através de um potencial modificado de Lennard-Jones. Os ângulos de torsão entre ligações sucessivas também contribuem no cálculo da função de energia \cite{benitez2015algoritmo}.
	
\end{itemize}




\subsection{Considerações Finais}
\label{Problema de Dobramento de Proteínas:Consideracoes Finais}

Neste seção o problema de dobramento de proteínas foi apresentado e sua importância para biológica computacional, química orgânica e medicina. Também foi mencionado que existem diversos modelos para representar estruturas de proteínas. Cada modelo tem suas peculiaridades e considera interações diferentes. Não existe um modelo que represente de maneira real o dobramento de proteínas, pois se trata de um processo ainda não completamente compreendido pelos cientistas e pesquisadores. Os modelos propostos tem diferentes níveis de detalhe e complexidade. O modelo mais simples é o HP mas apesar da sua simplicidade se apresenta como um problema $NP$-completo. O modelo HP será utilizado nesta proposta por conta de sua simplicidade de implementação, assim como o baixo custo computacional para realizar simulações do cálculo de energia. Utilizando o modelo HP diferentes maneiras de representar as variáveis existem. Nesta dissertação será utilizada a representação relativa pois é mencionado na literatura que esta tem uma maior capacidade de guiar algoritmos de busca a melhores resultados.


%=====================================================

\section{AEs - Algoritmos Evolucionários}

Um algoritmo evolucionário (AE) é uma técnica de busca, altamente paralela, inspirada na teoria da seleção natural e reprodução genética de Charles Darwin. De acordo com a teoria de Darwin, a seleção natural irá favorecer os indíviduos que forem mais aptos, dessa maneira, estes indíviduos tem uma maior probabilidade
de reprodução. Indivíduos com mais descendentes tem uma chance maior de perpetuarem seus códigos genéticos nas gerações futuras. O código genético é a identidade de cada indivíduo e é representado por cromossomos. Estes princípios são utilizados na implementação de algoritmos computacionais, que procuram por soluções melhores para um dado problema, evoluindo uma população 
de soluções codificadas em cromossomos artificais -- estruturas de dados utilizadas para representar soluções factíveis para um dado problema \cite{pacheco1999algoritmos}.

De maneira geral, problemas reais de otimização possuem múltiplos objetivos a serem minimizados/maximizados e estão presentes em muitas áreas do conhecimento.
Para otimizar problemas multiobjetivos, dois ou mais objetivos são considerados os quais geralmenta são conflitantes. Para estes problemas é impossível encontrar uma
única solução ótima. Um conjunto de soluções é encontrado avaliando a dominância de Pareto \cite{pareto} entre as soluções. O objetivo principal é encontrar o conjunto  
de soluções que sejam não dominadas entre si. Uma solução domina outra, se e somente se, for melhor em pelos um dos objetivos, sem ser pior em qualquer outro.
Este conjunto de soluções constitui a fronteira de Pareto. Encontrar a fronteira real de Pareto é um problema NP-Completo \cite{fonseca2005tutorial}, dessa maneira,
o objetivo é encontrar uma boa aproximação da fronteira real.

Algoritmos Evolucionários Multi-Objetivos (AEMOs) são extensões de AEs para problemas multi-objetivos os quais aplicam
conceitos da dominância de Pareto para criar diferentes estratégias para evoluir e manter a diversidade das soluções.
Nesta dissertação foram explorados dois AEMOs: NSGAII \cite{deb2002fast} and IBEA \cite{zitzler2004indicator}.
%=====================================================

\subsection{NSGAII - Non-dominated sorting Genetic Algorithm II}

O algoritmo \ref{alg:nsgaII} apresenta o pseudo código do NSGAII. O algoritmo recebe como parâmetro $N$ o tamanho da população e $T$ o número máximo 
de avaliações. O algoritmo inicia criando uma população com tamanho $N$ chamada $P_0$. A população $P_0$ é classificada de acordo com aptidão 
e a relação de não dominância. A população $P_0$ é submitida ao operador de seleção: torneio binário para selecionar duas soluções que serão utilizadas
para gerar descendentes. Operadores de cruzamento e mutação são aplicados na soluções selecionadas gerando duas soluções distintas descendentes. 
Ao fim do processo de reprodução as soluções descendentes são avaliadas e adicionadas a população chamada $Q_0$.

Após esta estapa, $P_0$ e $Q_0$ são adicionadas em uma população auxiliar chamada $R$. Utilizando o conceito de não dominância, $R$ é ordenada 
criando fronteiras, onde cada solução da primeira fronteira não é dominada por nenhuma outra solução, já soluções da segunda fronteira são dominadas
apenas por soluções contidas na primeira fronteira, e assim por diante. Para cada fronteira, as soluções são avaliadas utilizando um mecanismo
de \textit{Crowding-Distance} as soluções com maiores valores irão ser adicionadas na população da próxima geração chamada $P_t$ onde $t$ é a
avaliação corrente.

Após criar e preencher $P_t$ com as soluções não dominadas de todas as fronteiras, a população $P_t$ é avaliada e então passa para um novo
torneio binário e reprodução, dessa maneira, iniciando uma novo ciclo do algoritmo.

\begin{algorithm}[htb!]
	\begin{algorithmic}[1]
		\State{$N \gets$ Population Size}
		\State{$T \gets$ Max evaluations}
		\State{$P_0 \gets CreatePopulation(N);$}
		\State{$CalculateFitness(P_0);$}
		\State{$FastNonDominatedSort(P_0);$}
		\State{$Q_0 \gets 0$}
		\While{$Q_0 < N$}
		\State{$Parents \gets BinaryTournament(P_0);$}
		\State{$Offspring \gets CrossoverMutation(Parents);$}
		\State{$Q_0 \gets Offspring$}
		\EndWhile
		\State{$CalculateFitness(Q_0);$}
		\State{$t \gets 0$}
		\While{$t < T$}
		\State{$R_t \gets P_t \cup Q_t;$}
		\State{$Fronts \gets FastNonDominatedSort(R_t);$}
		\State{$P_{t+1} \gets 0$}
		\State{$i \gets 0$}
		\While{$P_{t+1} + Front_i  < N$}
		\State{$CrowdingDistanceAssignment(Front_i);$}
		\State{$P_{t+1} \gets P_{t+1} \cup Front_i$}
		\State{$i \gets i + 1$}
		\EndWhile
		\State{$CrowdingDistanceSort(Front_i);$}
		\State{$P_{t+1} \gets P_{t+1} \cup Front_i[1:(N -P_{t+1})]$}
		
		\State{$Parents \gets BinaryTournament(P_{t+1});$}
		\State{$Q_{t+1} \gets CrossoverMutation(Parents);$}
		\State{$t \gets t +1$}
		\EndWhile
		\State{\Return{$P \gets$ Set of non-dominated solutions.}}
	\end{algorithmic}
	\caption{NSGAII}
	\label{alg:nsgaII}
\end{algorithm}


%=====================================================

\subsection{IBEA (Indicator-Based Evolutionary Algorithm)}

No contexto de otimização multiobjetiva, otimizar consiste em tentar encontrar a fronteira com uma boa aproximação da fronteira real de Pareto. 
Entretanto, não existe uma definição geral para "uma boa aproximação". Consequentemente, indicadores de qualidade vem sendo utilizados
para avaliar a qualidade da aproximação de fronteiras. O indicador \textit{hypervolume} é um exemplo de indicador utilizado para avaliação e comparação 
das fronteiras.

No algoritmo IBEA, indicadores de qualidade são	utilizados para avaliar o conjunto de soluções não dominadas \cite{figueiredo2013algoritmo}.
Para utilizar o IBEA, é necessário definir qual indicador será utilizado para associar cada solução a um valor scalar. Um dos indicadores bastante utilizados
em conjunto com IBEA é o \textit{hypervolume} por conta da sua capacidade de avaliar a convergência e a diversidade do espaço de busca ao mesmo \cite{ishibuchi2008evolutionary}.

\begin{equation} \label{eq:ibeaFitness}
F(x_i) = \sum_{x_j \in (P-x_i)} {-e^\frac{-I_{Hy}(x_j,x_i)}{k}}
\end{equation}

A equação de \textit{fitness} do IBEA é apresentada pela equação \ref{eq:ibeaFitness} e é utilizada para calcular a contribuição de uma dada solução
para o valor do indicador referente a população, onde $k$ é um fator escalar dependente do $I_{Hy}$, o qual representa o indicador de qualidade sendo utilizado.
O valor $F(x_i)$ corresponde à perda de qualidade da aproximação, da fronteira real de Pareto, se a solução $x_i$ for removida da população \cite{figueiredo2013algoritmo}.


O Algoritmo \ref{alg:ibea} recebe como parametro o tamanho da população $N$, o número máximo de avaliações $T$ e o fator escalar $k$. O processo se inicia
criando uma população $P$ de tamanho $N$. Até que o critério de parada seja atingido os seguintes passos irão se repetir: um torneio binário 
para selecionar indivíduos, reprodução (cruzamento e mutação) dos indivíduos selecionados para gerar descendentes, adicionar os descedentes na população
auxiliar $\overline P$. Após a reprodução, a população $\overline P$ é unida com $P$. Enquanto o tamanho de $P$ exceder $N$, o pior indíviduo avaliado
pela equação \ref{eq:ibeaFitness} é removido da população $P$ e os indíviduos restantes são re-avaliados. Quando o algoritmo terminar irá retornar o conjunto
de soluções não dominadas é retornado.

\begin{algorithm}[htb!]
	\begin{algorithmic}[1]
		\State{$N \gets$ Population Size}
		\State{$\overline N \gets$ AuxiliaryPopulationSize}
		\State{$T \gets$ Max Evaluations}
		\State{$k \gets$ Scale factor of Fitness}
		
		\State{$P \gets$ CreatePopulation($N$);}
		\State{$\overline P \gets$ CreateEmptyAuxiliaryPopulation($\overline N$);}
		\State{$m \gets 0$}
		\State{CalculateFitness($P$);}
		
		\While{$m \ge T$ or other stop criterion is not reached}
		
		\State{$\overline P \gets$ BinaryTournament($P$);}
		\State{$\overline P \gets$ CrossoverMutation($\overline P$);}
		\State{$P \gets P \cup \overline P$}
		\State{$m \gets m+1$}
		
		\While{Size($P$) $> N$}
		\State{$x^* \gets$ WorstIndividualByFitness();}
		\State{RemoveFromPopulation($x^*$, $P$);}
		\State{CalculateFitness($P$);}
		\EndWhile
		
		\EndWhile
		\State{\Return{$P \gets$ Set of non-dominated solutions}}
		
	\end{algorithmic}
	\caption{IBEA}
	\label{alg:ibea}
\end{algorithm}

%\footnotetext[1]{\textit{Hypervolume}: Indicador de qualidade utilizado neste estudo \cite{zitzler1998multiobjective}, 
%	denotado como o "tamanho da área coberta do espaço de busca". Este indicador tem uma vantagen importante em relação aos outros \cite{zitzler2007hypervolume}:
%	1 - Sensitivo a qualquer tipo de melhoria na aproximação em relação a outro conjunto. 

\section{Hiper-Heurísticas }
\label{Hiper-Heuristicas}

Apesar do sucesso de métodos heurísticos e outros métodos de busca na tarefa de resolver problemas de busca computacional difíceis ainda existem dificuldades em generalizar estes métodos para diferentes problemas ou até mesmo para diferentes instâncias de um mesmo problema. Esta dificuldade provém principalmente da necessidade de selecionar os parâmetros e configurações mais adequados dos algoritmos para um problema ou para uma dada instância de um problema. Também vale mencionar a pouca orientação na tarefa de definir estes parâmetros.  É neste contexto que surge uma questão: é possível automatizar o projeto e parametrização de métodos heurísticos para resolver problemas de busca computacional difíceis? \cite{burke2013hyper}. A ideia principal é desenvolver algoritmos que sejam mais genéricos do que as implementações de metodologias atuais \cite{burke2013hyper}. As principais abordagens já propostas para este desafio podem ser classificadas em duas categorias: configuração estática (\textit{offline}) e controle dinâmico (\textit{online}). Abaixo são apresentadas algumas abordagens já propostas na literatura:

\begin{itemize}
	\item Configuração Estática (Offline):
	\begin{itemize}
		\item Seleção de algoritmos;
		\item Portfólio de algoritmos;	
		\item Configuração de algoritmos;
		\item Ajuste de parâmetros;
		\item Hiper-Heurísticas.
	\end{itemize}
	\item Controle Dinâmico (Online):
	\begin{itemize}
		\item Seleção adaptativa de operadores (AOS);
		\item Controle de parâmetros;	
		\item Algoritmos meméticos adaptativos;
		\item Hiper-Heurísticas
	\end{itemize}
	
\end{itemize}


Esta seção tratará apenas de hiper-heurísticas e suas particularidades. Uma hiper-heurística pode ser vista como uma metodologia de alto nível, a qual seleciona ou cria heurísticas para resolver um dado problema ou instância de um problema. \cite{burke2013hyper}. O objetivo principal é tentar encontrar ou construir a heurística mais adequada para cada situação. As hiper-heurísticas diferem dos métodos padrão de busca pois operam sobre o espaço de busca de heurísticas que por sua vez operam sobre o espaço de busca de um problema. Além disso, hiper-heurísticas são independentes do problema. Tradicionalmente frameworks hiper-heurísticos possuem dois níveis: \cite{sabar2014automatic}

\textbf{Heurísticas de baixo nível}:  Um conjunto de heurísticas de baixo nível específicas. Estas heurísticas costumam diferir entre domínios de problemas. São exemplos: operadores de cruzamento, mutação e buscas locais. Em alguns casos, meta-heurísticas também, dependendo da modelagem do \textit{framework} hiper-heurístico, podem assumir o papel de heurísticas de baixo nível. 

\textbf{Heurísticas de alto nível}: Geralmente consistem em dois componentes: mecanismo de seleção, que gerencia quais heurísticas de baixo nível devem ser aplicadas durante a busca; um critério de aceitação, que tem a responsabilidade de decidir se irá aceitar ou não uma solução gerada, a partir da aplicação de uma heurística de baixo nível. A responsabilidade do mecanismo de seleção é selecionar, de um \textit{pool} de heurísticas de baixo nível, a heurística que for mais adequada naquele momento. Geralmente, a escolha da heurística de baixo nível é crucial para uma boa exploração do espaço de busca, evitando que a busca fique confinada em uma região específica \cite{sabar2015automatic}. O objetivo do critério de aceitação é auxiliar o processo de busca a evitar mínimos locais assim como explorar diferentes regiões através do aceite ou rejeição de soluções geradas \cite{chakhlevitch2008hyperheuristics}. Espera-se que um bom critério de aceitação deva atingir um bom equilíbrio entre aceitar soluções melhores assim como soluções diversificadas se a busca estiver presa em um mínimo local \cite{sabar2015automatic}. Ambos os componentes devem ser independentes de conhecimento sobre o problema.

A imagem \ref{img:hiperheuristico} apresenta um diagrama exemplificando os níveis de um \textit{framework} hiper-heurístico e suas características. Note que entre os níveis (alto e baixo) existe uma barreira de domínio, ou seja, apenas as heurísticas de baixo nível são dependentes de conhecimento do problema ou instância e as heurísticas de alto nível não são dependentes do problema. 

\begin{figure}[!htb]
	\centering
	\includegraphics{Imagens/HiperHeuristicas.png}
	\caption{Framework Geral Hiper-Heurístico. Adaptado de \cite{sabar2015automatic}}
	\label{img:hiperheuristico}
\end{figure}


Como cada instância ou problema possui um espaço de busca com diferentes características, os componentes da heurística de alto nível têm um grande impacto no desempenho de um \textit{framework} hiper-heurístico. Esta é uma das razões de existir um grande interesse de pesquisa em desenvolver  novos mecanismos de seleção, assim como diferentes critérios de aceitação \cite{burke2013hyper}. Um bom mecanismo de seleção deve selecionar a heurística mais adequada em um dado momento, para guiar a busca para regiões promissoras do espaço de busca. 
Ao utilizar hiper-heurísticas, espera-se encontrar o método correto ou a sequência de heurísticas que mais se adequam a um problema ou instância ao invés de tentar resolver o problema diretamente. Entretanto, um importante objetivo é desenvolver métodos genéricos, que têm  potencial em produzir soluções com uma qualidade aceitável, utilizando um conjunto de heurísticas de baixo nível fácil de implementar. As hiper-heurísticas podem ser classificadas de diversas maneiras. A figura \ref{img:classificacaoHiperHeuristicas} apresenta as possíveis classificações descritas na literatura. 

\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.8]{Imagens/ClassificacaoHiperHeuristica.png}
	\caption{Classificação Hiper-heurísticas. Adaptado de \cite{sabar2015automatic}}
	\label{img:classificacaoHiperHeuristicas}
\end{figure}

A primeira classificação de hiper-heurísticas é baseada na sua fonte de conhecimento durante a busca: \textit{Online} é quando a hiper-heurística toma decisões de maneira instantânea, baseando-se em métricas durante sua execução, não necessitando de treinamento prévio. \textit{Offline} necessita de treinamento prévio; estes \textit{frameworks}  tomam suas decisões baseados no que foi aprendido apenas durante o treinamento, sem atualização deste conhecimento. Os \textit{frameworks} classificados como \textit{No-Learning} não possuem nenhuma forma de aprendizagem. Outra classificação considera como as heurísticas de baixo nível operam sobre as soluções do problema. As heurísticas ditas perturbativas realizam pequenas perturbações nas soluções gerando novas soluções. Já heurísticas construtivas criam soluções do zero passo a passo e normalmente avaliam cada etapa da construção para obter \textit{feedback} sobre o seu desempenho. Uma última  classificação, mas não menos importante, divide as hiper-heurísticas de acordo com a  natureza do seu espaço de busca. As hiper-heurísticas de seleção selecionam sequências de heurísticas a serem aplicadas para resolver um dado problema ou instância. Já as hiper-heurísticas de geração operam gerando novas heurísticas com objetivo de resolver um problema ou instância.


\subsection{Hiper-heurísticas de Geração}
\label{Hiper-Heuristicas-Geraçao}

Estas hiper-Heurísticas geram novas heurísticas combinando componentes de heurísticas existentes. Geralmente se utiliza programação genética (GP), ou alguma vertente de GP, como por exemplo evolução gramatical \cite{ryan1998grammatical} ou programação gênica \cite{ferreira2006gene}, como hiper-heurística para gerar heurísticas. A próxima sub-seção irá introduzir o conhecimento necessário para a compreensão da programação genética, assim como irá introduzir evolução gramatical, que se trata de um tipo de programação genética e que será utilizada nesta proposta.

\section{Programação Genética (PG)}
\label{subsection:PG}

Programação Genética \cite{burke2009exploring} é um ramo da síntese de programas que utiliza ideias oriundas da teoria da evolução natural para produzir programas. Os principais componentes da computação evolucionária são herança (cruzamento/reprodução), seleção e variação (mutação). A herança significa que os descendentes  têm alguma semelhança com seus pais, pois quase todo material genético vem dos pais. A seleção trata de escolher quais pais irão se reproduzir para gerar novos descendentes; pais com maior aptidão tendem a ter maior probabilidade de serem selecionados. Esta pressão de seleção define quais indivíduos estão mais aptos que outros. Variação realiza pequenas alterações em um descendente a fim de criar novo material genético neste indivíduo e que não estava presente em nenhum dos indivíduos que o geraram. Computação evolutiva pode ser pensada como a interação destes três componentes. 
Uma população aleatória de programas de computador é gerada, e os operadores geneticamente inspirados (cruzamento e mutação) são repetidamente aplicados com objetivo de produzir novos programas de computador. Estes programas são avaliados utilizando uma função de \textit{fitness} (normalmente dependente do desempenho obtido pela aplicação do programa em um problema), que determina quais destes programas são mais suscetíveis a sobreviver para gerações futuras. Os programas com maior aptidão tem mais chances de serem selecionados para o cruzamento e perpetuarem parte de seus códigos genéticos durante o processo evolutivo. 
Programação genética é um método de geração de programas sintaticamente válidos e a função de \textit{fitness} é utilizada para decidir quais programas são mais adequados para o problema.
Na programação genética, os programas que compõem a população são tradicionalmente representados utilizando estruturas de árvore. Existem outras estruturas que podem ser evoluídas, como por exemplo: sequências lineares de instruções ou gramáticas. Nesta proposta será utilizada uma representação gramatical linear que será explicada na seção \ref{subsubsection:EvolucaoGramatical}.

\section{Evolução Gramatical (EG)}
\label{subsubsection:EvolucaoGramatical}

Evolução gramatical é uma técnica relativamente nova de computação evolutiva, proposta por Ryan et al. \cite{ryan1998grammatical}, trata-se de um tipo de programação genética. Assim como na programação genética, o principal objetivo é encontrar um programa executável ou trecho de um programa, que obtenha um bom valor de \textit{fitness} para o problema em questão. Na maioria dos trabalhos publicados de programação genética, expressões que representam estruturas de árvore são manipuladas, enquanto na evolução gramatical os operadores genéticos são aplicados em vetores de inteiros que posteriormente são mapeados para um programa (ou trecho de programa) através de uma gramática específica. Um dos benefícios de EG é que este mapeamento generaliza a aplicação para diferentes linguagens de programação.
Ryan el al. \cite{ryan1998grammatical} propõem uma técnica para gerar programas ou fragmentos de programas para qualquer linguagem de programação utilizando definições BNF. A técnica pode ser utilizada para evoluir programas por um processo evolutivo. A evolução gramatical adota um mecanismo de mapeamento entre o genótipo (indivíduos codificados em um vetor de inteiros) e o fenótipo (programas gerados para resolver algum problema). 
A notação \textit{Backus Naur Form} (BNF) é a notação utilizada para expressar a gramática de uma linguagem na forma de regras de produção. Uma gramática BNF consiste em um conjunto de terminais, os quais são itens que podem aparecer na linguagem, por exemplo: +, -, *, / etc e não terminais, que podem ser expandidos em um ou mais terminais e não terminais. Uma gramática pode ser expressada como uma tupla ${N,T,P,S}$, onde $N$ é o conjunto de não terminais, $T$ o conjunto de terminais, P um conjunto de regras de produção que mapeia os elementos $N$ para $T$; e, por último, $S$, um símbolo de início e que está contido em $N$.

\begin{center}
	
	$ N = {\langle expr \rangle, \langle op \rangle, \langle pre-op \rangle}$
	
	$ T = {Sin,Cos,Tan,Log,+,-,/,*,X} $
	
	$ S = \langle expr \rangle $
	
\end{center}

\noindent
E $P$ pode ser representada como:

\begin{Grammar}
	\begin{grammar}
		
		
		<expr> ::=  <expr> <op> <expr> \hspace{10cm} (0) 
		\alt (<expr> <op> <expr>) \hspace{9.7cm} (1)  
		\alt <pre-op> (<expr>) \hspace{10.15cm} (2) \alt <var> \hspace{12.1cm} (3) \\\
		
		<op> ::=  + \hspace{12.7cm} (0)   \alt - \hspace{12.8cm} (1)  \alt  /  \hspace{12.85cm} (2) \alt * \hspace{12.75cm} (3) \\
		
		<pre-op> ::= Sin  \hspace{12.4cm} (0) \alt Cos
		\hspace{12.3cm} (1) \alt Tan  \hspace{12.35cm} (2) \alt Cos \hspace{12.3cm} (3) \\
		
		<var> ::= X  \hspace{12.6cm} (0)
		
		
	\end{grammar}
	
	\caption{Gramática exemplo para demonstrar como decodificar vetores de inteiros em programas de computador.}
	\label{gram:gramatica}
\end{Grammar}


\begin{table}[htb]
	\centering
	\caption{\textit{Regras de produção} e o número de escolhas para cada uma.}
	\label{tab:productionRules}
	\begin{tabular}{|l|l|}
		\hline
		Regra de produção & Número de escolhas \\ \hline
		$\langle expr \rangle$                        & 4       \\ \hline
		$\langle op \rangle$                         & 4       \\ \hline
		$\langle pre-op \rangle$                         & 4       \\ \hline
		$\langle var \rangle$                          & 1       \\ \hline
	\end{tabular}
\end{table}


Ryan et al. \cite{ryan1998grammatical}  propôs o uso de um algoritmo genético (AG) para controlar quais escolhas devem ser feitas, permitindo dessa maneira que o AG controle quais regras de produção serão utilizadas. Um indivíduo (cromossomo) consiste em um vetor de tamanho variável de valores inteiros que representa o genótipo. Para fins de compreensão o processo de mapeamento de um cromossomo será demonstrado utilizando a \autoref{gram:gramatica} apresentada anteriormente nesta seção. O Algoritmo \ref{alg:pseudocodigogrammar} apresenta o \textit{template} geral dos programas gerados pela \autoref{gram:gramatica}. A expressão $\langle expr \rangle$ apresentada na linha 2 do Algoritmo \ref{alg:pseudocodigogrammar} é substituída por expressões matemáticas que estão codificadas pelos cromossomos (vetores de inteiros). 

\begin{algorithm}
	\caption{\textit{Template} geral dos algoritmos gerados}
	\label{alg:pseudocodigogrammar}
	float symb(float x) { \\
		a = $\langle expr \rangle$;   \\
		return a;  \\
	}	
\end{algorithm}

\noindent
Suponha o seguinte vetor de inteiros:

\begin{center}
	$ [220, 203, 17, 6, 108, 215, 104, 30] $
\end{center}


Este vetor será utilizado para mapear o cromossomo (genótipo) em um trecho de programa (fenótipo) utilizando a gramática BNF. 
%A expressão não terminal $ \langle expr \rangle$ no algoritmo \ref{alg:pseudocodigogrammar} será preenchida por um trecho de código que será mapeado a partir do cromossomo apresentado. Os passos do mapeamento serão descritos a seguir.%
A tabela \autoref{tab:productionRules} resume o número de escolhas associada à cada regra de produção da \autoref{gram:gramatica}. Existem 4 opções de regras de produção que podem ser selecionadas para a expressão $ \langle expr \rangle$. Para decidir qual será selecionada, o primeiro valor no cromossomo deve ser utilizado. O valor é 220. Devemos realizar o módulo deste valor pelo número de escolhas, neste caso 4. Portanto, 220 MOD 4 = 0, o que significa selecionar a primeira opção: $\langle expr \rangle \langle op \rangle \langle expr \rangle$.

Note que a primeira expressão é novamente $ \langle expr \rangle$ e da mesma maneira devemos obter o próximo valor de inteiro e realizar o módulo. O próximo valor inteiro é 203; realizando o modulo de 4, resulta em 3, que portanto seleciona a quarta opção: $ \langle var \rangle$. Substituindo na expressão anterior, obtemos: $ \langle var \rangle \langle op \rangle \langle expr \rangle$

Nenhuma escolha é necessária para a expressão $ \langle var \rangle$, pois existe apenas uma opção $X$. A expressão pode ser reescrita da seguinte maneira: $X \langle op \rangle \langle expr \rangle$

Neste momento é necessário decodificar a expressão não terminal $\langle op \rangle$. Obtendo o próximo valor inteiro do cromossomo, temos 17 e para o $ \langle op \rangle$ temos 4 opções $(+ | - | / | *)$. O resultado de 17 MOD 4  é igual a 1, que significa selecionar:  $-$. Substituindo na expressão, temos: $X  -  \langle expr \rangle$


Novamente é necessário fazer uma nova escolha para resolver a expressão não terminal $\langle expr \rangle$. O próximo valor do cromossomo é 6 e novamente existem 4 opções. Realizando o modulo 6 MOD 4, obtém-se 2, que seleciona $ \langle pre-op \rangle ( \langle expr \rangle)$. Atualizando a expressão, obtemos: $X - \langle pre-op \rangle (\langle expr \rangle)$

Resolvendo a expressão $ \langle pre-op \rangle$, obtemos 108 MOD 4 = 0 que por sua vez seleciona a primeira expressão  terminal $Sin$. Atualizando a expressão, obtemos: $X - Sin (\langle expr \rangle)$

Expandindo $ \langle expr \rangle$, obtemos 215 MOD 4 = 3, que seleciona a expressão não terminal $ \langle var \rangle$. Já que para a expressão $ \langle var \rangle$ existe apenas uma opção, nenhuma escolha é necessária e a expressão final decodificada (fenótipo) é: $X - Sin (X)$

Note que nem todos os genes do cromossomo foram necessários para obter o fenótipo. Nos casos em que isto ocorre, os genes que não forem utilizados são desconsiderados. Além disso, pode ocorrer que um cromossomo não tenha genes suficientes para mapear um programa. Neste caso a estratégia é reutilizar os genes do cromossomo a partir do primeiro gene. 

Operadores genéticos tradicionais (cruzamento e mutação) também são utilizados na EG. Além dos operadores tradicionais outros dois operadores \textit{Prune} e \textit{Duplicate} são peculiares à EG e serão descritos em seguida:

\begin{itemize}
	\item \textit{Duplicate}: Este operador (dada uma probabilidade) realiza a cópia de  alguns genes. Os genes duplicados são adicionados após a última posição do cromossomo. O número de genes a serem duplicados é selecionado de maneira aleatória. A motivação por trás deste operador é que ao duplicar genes ocorre um aumento da presença de genes que são potencialmente bons, pois pertencem a um indivíduo com boa aptidão selecionado pelo operador de seleção.
	\item \textit{Prune} : Este operador leva em consideração que nem sempre todos os genes, de um cromossomo, são utilizados para decodificar um programa. Dessa maneira (dada uma probabilidade) realiza o truncamento de  cromossomos. O objetivo é diminuir a probabilidade que o operador de cruzamento opere em regiões dos cromossomos que não sejam utilizadas realmente.
\end{itemize}


O Algoritmo \ref{alg:GE} apresenta o pseudocódigo da evolução gramatical (EG). Note que o pseudocódigo é muito similar a um algoritmo genético simples. Nas linhas 3 e 4 ocorre a inicialização da população e o mapeamento para programas utilizando a gramática que foi provida como entrada. Em seguida, na linha 5 ocorre a execução dos programas e na linha 6 acontece a avaliação dos indivíduos da população, baseando-se na saída obtida pelos respectivos programas. Dentro do laço principal, apresentado na linha 7, podemos observar o processo de seleção dos indivíduos pais na linha 8 e na linha 9 o processo de cruzamento destes indivíduos. Nas linhas 10 e 11 ocorre a aplicação dos operadores \textit{Prune} e \textit{Duplicate} respectivamente e na linha 12 podemos observar a aplicação do operador de mutação. Em seguida, nas linhas 13,14 e 15 ocorre o mapeamento dos indivíduos descendentes para programas, execução dos programas e finalmente a atribuição de \textit{fitness} para os descendentes. Por fim, na linha 16 do laço principal, ocorre a substituição dos descendentes na população. 


%exceto pela aplicação dos operadores \textit{Duplicate} e \textit{Prune} (linhas 10 e 11 do Algoritmo  \ref{alg:GE}) e o processo de decodificação e execução dos programas descendentes (linhas 13 e 14 do Algoritmo \ref{alg:GE}).

%\begin{algorithm}[htb]
%	\fontsize{8pt}{10pt}\selectfont
%	\caption{Pseudocódigo da evolução gramatical}
%	\label{alg:GE}
%	\KwIn{AG -- Arquivo da gramática}
%	\Begin{
%		$populacao \gets$ Inicialização a população\;
%		$programas \gets$ Mapeia $populacao$ para programas utilizando $AG$\;
%		Executa os $programas$\;
%		Atribui valor de \textit{fitness} para as soluções  of $populacao$ de acordo com a saída obtida pelos respectivos programas decodificados\;
%		\While{Condição de parada não atingida}{
%			$pais \gets $ Seleção de indivíduos para cruzamento\;
%			$descendentes \gets$ Cruzamento $pais$\;
%			Aplica o operator \text{Prune} nas soluções $descendentes$\;
%			Aplica o operador \textit{Duplicate} nas soluções $descendentes$\;
%			Aplica o operador de mutação nas soluções $descendentes$\;
%			$programas \gets$ Mapeia $descendentes$ para programas utilizando $AG$\;
%			Executa $programas$\;
%			Atribui valor \textit{fitness} para as soluções $descendentes$ de acordo com a saída obtida pelos respectivos programas decodificados\;
%			$populacao \gets$ Realiza substituição\;
%		}
%		\Return{Melhor programa da $populacao$}\;
%	}
%\end{algorithm}


\section{Programação Genética como Hiper-Heurística de Geração de Heurísticas}
\label{subsubsection:PGasHH}

Nesta seção serão apresentadas questões relativas ao uso de EG como mecanismo de geração de heurísticas. 
Burke et al. \cite{burke2009exploring} descrevem que muitos autores mencionam a melhor adequação de programação genética, em relação a outras técnicas de aprendizagem de máquina, para gerar heurísticas de maneira automática. Burke et al \cite{burke2009exploring} também apontam algumas vantagens desta técnica:

\begin{itemize}
	\item PG utiliza cromossomos de tamanho variável. Geralmente, não se sabe um tamanho ótimo para representar heurísticas de um dado domínio de problema.
	\item PG produz estruturas de dados executáveis. E heurísticas são tipicamente expressadas como programas ou algoritmos.
	\item Facilidade em identificar boas características do domínio do problema, afim de definir o conjunto terminal que será utilizado pela PG.
	\item Heurísticas desenvolvidas por humanos podem facilmente ser expressadas na mesma linguagem utilizada para criar o espaço de busca da PG. O conjunto de funções, relevante para o problema pode ser determinado facilmente. E adicionalmente PG pode ser suplementada com uma gramática específica.
\end{itemize}

Todas estas vantagens descritas por Burke et al. \cite{burke2009exploring} também são consideradas ao utilizar EG, visto que se trata de uma extensão de programação genética e possui as mesmas características (cromossomo de tamanho variável, produz estruturas executáveis, etc).
Burke et al. \cite{burke2009exploring} também mencionam desvantagens, por exemplo: a cada execução da programação genética é encontrada uma melhor heurística que, por se tratar de uma técnica estocástica, os resultados podem ser distintos em diferentes execuções. Portanto se fazem necessárias múltiplas execuções, a fim de se obter um melhor conhecimento da qualidade das heurísticas que podem ser produzidas. Outra desvantagem é referente à configuração de parâmetros, que normalmente é encontrada via tentativa e erro.

\subsubsection{Abordagem Básica}

Burke et al. \cite{burke2009exploring} descrevem uma abordagem básica para aplicar programação genética para gerar heurísticas:

\begin{enumerate}
	\item Examinar as heurísticas existentes: Avaliar se as heurísticas já propostas para um dado problema podem ser descritas em um \textit{framework} comum. Estas heurísticas podem ter sido criadas por humanos ou até mesmo concebidas via outras técnicas de aprendizagem. Este passo não é trivial, pois envolve o entendimento de um número diverso de heurísticas existentes, que podem operar de diferentes maneiras. Geralmente heurísticas desenvolvidas por humanos são produtos de anos de pesquisa, portanto uma boa compreensão das heurísticas existentes pode ser um trabalho difícil. 
	\item Um framework que utilizará as heurísticas: neste momento a preocupação é em como as heurísticas serão aplicadas para um dado problema. Em geral, os frameworks tendem a ser bem diferentes dependendo do domínio do problema. 
	\item Definição do conjunto terminal: neste passo a preocupação refere-se a variáveis que expressem o estado do problema. Estas variáveis irão compor os terminais da programação genética/evolução gramatical. Outros terminais também podem ser utilizados. Particularmente, constantes aleatórias podem ser úteis.
	\item Definição do conjunto de funções: é necessário definir como as variáveis estarão relacionadas ou combinadas entre si. Estes relacionamentos irão compor o conjunto de funções da programação genética/evolução gramatical. 
	\item Identificar uma função de \textit{fitness}: uma função de \textit{fitness} precisa ser identificada para o problema. Geralmente, uma função simples de aptidão não irá avaliar bem os cromossomos. Introduzir alguns parâmetros pode ajudar a encontrar uma mais adequada.
	\item Executar o framework: geralmente ao executar pela primeira vez um framework hiper-heurístico com programação genética, não serão produzidos bons resultados, devido à escolha dos parâmetros. Isto é observado especialmente em casos que o pesquisador é iniciante. Portanto é essencial que as definições de parâmetros sejam cuidadosamente investigadas.
\end{enumerate}




\section{Considerações Finais}
\label{ReferencialTeorico:ConsideracoesFinais}


Neste capítulo foram apresentados os conceitos que permeiam a área de estudo sobre hiper-heurísticas, tendo sido discutidos os seus níveis (alto e baixo) e as classificações encontradas na literatura.  Foram discutidas algumas estratégias para hiper-heurísticas de seleção e geração. As hiper-heurísticas de geração foram mais detalhadas, pois esta proposta visa o projeto  automático de heurísticas de alto nível. Foram apresentados os conceitos de PG e sua extensão EG, por se tratarem de estratégias comumente utilizadas para o projeto de hiper-heurísticas de geração de heurísticas. Também foram discutidas algumas vantagens e desvantagens referentes ao uso de PG para geração de heurísticas, além de demonstrar que a EG possui as mesmas características da PG, pois se trata de uma extensão que utiliza uma gramática para gerar os programas. O funcionamento geral da EG foi demonstrado utilizando uma gramática exemplo e um vetor de inteiros e, por fim, o pseudocódigo da evolução gramatical foi apresentado. O  \autoref{Problema de Dobramento de Proteínas} apresenta o problema de dobramento de proteínas e o \autoref{Metodologia} apresentará a proposta da aplicação de EG a este problema.






\section{Exemplo de figura}

A forma sugerida para incluir figuras em um documento \LaTeX\ é importá-las usando o pacote \texttt{graphicx}. Como formatos gráficos sugere-se:

\begin{itemize}

\item Formatos \emph{raster}, como PNG (\emph{Portable Network Graphics}) ou JPG (\emph{Joint Photographic Experts Group}) para fotografias; procure usar uma resolução de ao menos 150 dpi (\emph{dots per inch}).

\item Formatos vetoriais, como PDF (\emph{Portable Document Format}) ou EPS (\emph{Extended PostScript}) para diagramas e gráficos\footnote{NUNCA use JPG ou GIF para desenhos vetoriais, pois o resultado final geralmente fica borrado.}.

\end{itemize}

A maior parte das ferramentas permite exportar figuras nesses formatos (a figura do exemplo foi produzida com o \emph{Inkscape}, um programa livre multiplataforma). A figura \ref{fig:comun-intra-inter} mostra um exemplo de inclusão de figura em PDF.

% exemplo de inserção de figura
\begin{figure}[!htb]
\centering
\includegraphics[width=12cm]{exemplo-figura.pdf}
\caption{Comunicação inter-processos.}
\label{fig:comun-intra-inter}
\end{figure}

Para mais informações consulte \cite{goossens93}.

%=====================================================

\section{Exemplo de tabela}

Tabelas são elementos importantes de um documento. No \LaTeX\ as tabelas podem ser objetos flutuantes (definidas no ambiente \texttt{table} e referenciadas por números usando \texttt{label} e \texttt{ref}) ou objetos fixos simples, criados pelo ambiente \texttt{tabular}. A tabela \ref{tab:modelos} é um exemplo de tabela flutuante, cuja posição no texto pode variar em função das quebras de página.

\begin{table}[!htp]
\centering
\caption{Os 16 modelos centrais do UCON$_{\mathrm{ABC}}$}
\label{tab:modelos}
\begin{tabular}{|c|cccc|}
\cline{2-5}
\multicolumn{1}{c|}{}& 0 (imutável) & 1 (\emph{pre-update}) & 2 (\emph{on-update}) & 3 (\emph{pos-update}) \\
\hline
\texttt{preA} & \textbullet & \textbullet & -- & \textbullet \\
\hline
\texttt{onA} & \textbullet & \textbullet & \textbullet & \textbullet \\
\hline
\texttt{preB} & \textbullet & \textbullet & -- & \textbullet \\
\hline
\texttt{onB} & \textbullet & \textbullet & \textbullet & \textbullet \\
\hline
\texttt{preC} & \textbullet & -- & -- & -- \\
\hline
\texttt{onC} & \textbullet & -- & -- & -- \\
\hline
\end{tabular}
\end{table}

%=====================================================

\section{Exemplo de equação}

Equações destacadas devem ser numeradas como mostra a equação \ref{eq:relatividade}:

\begin{equation}
E = m \times c^2
\label{eq:relatividade}
\end{equation}

%=====================================================

\section{Exemplos de código-fonte}

Códigos-fonte podem ser produzidos de forma simples através do ambiente \texttt{verbatim}, como mostra este exemplo:

\begin{footnotesize}
\begin{verbatim}
#include <stdio.h>

int main (int argc, char *argv[])
{
   int i ;                           // uma variavel local

   for (i=0; i< 100; i++)            // um laço for
      printf ("i vale %d\n", i) ;    // uma saída na tela
}
\end{verbatim}
\end{footnotesize}

No entanto, é preferível usar pacotes especializados para a edição ou inclusão de códigos-fonte, como o pacote \texttt{listings}. Eis um exemplo de código-fonte escrito com esse pacote:

% exemplo de código-fonte definido no próprio texto

\begin{lstlisting}
#include <stdio.h>

int main (int argc, char *argv[])
{
   int i ;                           // uma variável local

   for (i=0; i< 100; i++)            // um laço for
      printf ("i vale %d\n", i) ;    // uma saída na tela
}
\end{lstlisting}

Esse pacote também permite incluir códigos-fonte de arquivos externos. Eis um exemplo:

% exemplo de código-fonte incluso

\lstinputlisting{2-fundam/exemplo.c}

%=====================================================

%\section{Exemplo de algoritmo}
%
%Os pacotes \texttt{algorithm} e \texttt{algorithmic} permitem formatar algoritmos facilmente. Eis um exemplo:
%
%\begin{algorithm}[H]
%\caption{Ações de $s_i$ ao encerrar um ciclo:}
%\label{alg:on-period-ending}
%\begin{small}
%\begin{algorithmic}[1]
%\FORALL{$x \in \mathcal{K}_i$}
%  \STATE{$\mathit{banned}_i(x) \gets$ FALSE}
%  \STATE{$mi_i(x) \gets 0$}
%  \STATE{$mm_i(x) \gets 0$}
%  \STATE{$\mathit{age}_i(x) \gets \mathit{age}_i(x) + 1$}
%  \IF{$\mathit{age}_i(x) = \mathit{age}_\mathit{max}$}
%     \STATE{$\mathcal{K}_i \gets \mathcal{K}_i - \{x\}$}
%     \COMMENT{``esquece'' do servidor $x$}
%     \STATE{remove as informações locais sobre $x$}
%     \STATE{envia $\mathit{notify}(x,\mathit{undef})$ ao grupo de confiança $\mathcal{T}_i$}
%  \ENDIF
%\ENDFOR
%\end{algorithmic}
%\end{small}
%\end{algorithm}
 
%=====================================================

\section{Conclusão}

Todo capítulo (com exceção da introdução e da conclusão) deve encerrar com uma pequena conclusão local, resumindo os tópicos apresentados no capítulo e preparando o leitor para o próximo capítulo (exceto se esse for a conclusão geral). Caso o capítulo tenha apresentado resultados obtidos pelo próprio autor, estes devem ser sucintamente relembrados aqui.

%=====================================================
